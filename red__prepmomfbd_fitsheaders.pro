; docformat = 'rst'

;+
; Write FITS header files for expected MOMFBD output.
; 
; :Categories:
;
;    SST pipeline
; 
; 
; :Author:
; 
;    Mats LÃ¶fdahl, ISP
; 
; 
; 
; :Keywords:
;
;    no_pd : in, optional, type=boolean
;   
;       Set this to exclude phase diversity data and processing. 
;   
;    momfbddir : in, optional, type=string, default='momfbd'
;   
;       Top directory of output tree.
;   
; 
;    dirs : in, optional, type=strarr
;   
;       The data "timestamp" directories to process.
;   
;    pref : in, optional, type=string
;
;       Prefilter. 
; 
; :History:
; 
;    2017-03-16 : MGL. First version.
; 
;    2017-03-24 : MGL. Add header information about this processing step.
; 
;    2017-06-01 : MGL. Use red_fitsaddpar. Change some added parameters.
;
;    2017-09-07 : MGL. Changed red_fitsaddpar --> red_fitsaddkeyword. 
; 
;    2018-03-29 : MGL. Make fitsheader files for extra WB objects
;                 generated by use of TRACE keyword in redux config
;                 file.
; 
;    2024-06-10 : MGL. Rewritten to cope better with both TRACE
;                 objects and mosaic observations.
; 
;-
pro red::prepmomfbd_fitsheaders, dirs = dirs $
                                 , momfbddir = momfbddir $
                                 , mosaic = mosaic $
                                 , no_narrowband = no_narrowband $
                                 , pref = pref $
                                 , scanno = scanno $
                                 , no_pd = no_pd 
  
  ;; Name of this method
  inam = red_subprogram(/low, calling = inam1)  

  if n_elements(dirs) gt 0 then begin
    dirs = [dirs] 
  endif else begin
    if ~ptr_valid(self.data_dirs) then begin
      print, inam+' : ERROR : undefined data_dir'
      return
    endif
    dirs = *self.data_dirs
  endelse
  
  Ndirs = n_elements(dirs)
  if Ndirs eq 0 then return

  if n_elements(momfbddir) eq 0 then begin
    if keyword_set(no_pd) then begin
      momfbddir = 'momfbd_nopd' 
    endif else begin
      momfbddir = 'momfbd' 
    endelse
  endif

  ;; Loop directories
  for idir=0L, Ndirs-1 do begin
    
    dir = dirs[idir]+'/'
    folder_tag = file_basename(dir)
    datestamp = self.isodate+'T'+folder_tag
    
    ;; base output location
    cfg_base_dir = self.out_dir + PATH_SEP() + momfbddir + PATH_SEP() + folder_tag + PATH_SEP()

    if n_elements(pref) gt 0 then begin
      prefs = pref
      Nprefs = n_elements(prefs)
    endif else begin
      prefs = file_basename(file_search(cfg_base_dir+'*', count = Nprefs))
    endelse
    
    for ipref = 0, Nprefs-1 do begin
      
      cfg_dir = cfg_base_dir + PATH_SEP() + prefs[ipref] + PATH_SEP() + 'cfg/'
      if keyword_set(mosaic) then begin
        ;; For automatic mosaic observations
        cfg_files = file_search(cfg_dir + 'momfbd_reduc_mos??_' + prefs[ipref] $
                                + '_?????.cfg', count = Ncfg)
      endif else begin
        ;; For regular observations
        cfg_files = file_search(cfg_dir + 'momfbd_reduc_' + prefs[ipref] $
                                + '_?????.cfg', count = Ncfg)                                      
      endelse 
      
      ;; Parse all config files, make fitsheaders for all output files
      for icfg = 0, Ncfg-1 do begin

        progress_msg = 'Making fits headers for ' $
                       + red_strreplace(red_strreplace(cfg_dir,'//','/') $
                                        , self.out_dir,'') 
        
        red_progressbar, icfg, Ncfg, progress_msg, /predict

        if keyword_set(mosaic) then begin
          ;; To be written to headers
          mos_tile = long(strmid(file_basename(cfg_files[icfg]), 16, 2))        
        endif else undefine, mos_tile

        if n_elements(scanno) ne 0 then $
           if long(scanno) ne long((strsplit(file_basename(cfg_files[icfg],'.cfg') $
                                             ,'_',/extract))[3]) then $
                                                continue

        cfginfo = redux_readcfg(cfg_files[icfg])
        cfgkeys = cfginfo.keys()
        Nkeys = cfginfo.count()
        
        spawn, 'cat '+cfg_files[icfg], cfg
        Nlines = n_elements(cfg)

        objinfo = redux_cfggetkeyword(cfginfo,'OBJECT0')
        objkeys = objinfo.keys()
        tmp = where(strmatch(objkeys.toarray(),'CHANNEL*'), Nchan)
        has_diversity = Nchan gt 1

        ;; Find out whether this is a cfg file with TRACE so we have
        ;; to generate fitsheader files for the implicit extra WB
        ;; output files.
        if redux_cfggetkeyword(cfginfo,'TRACE') then begin
          Ntrace = 2
;          wbout = file_basename(redux_cfggetkeyword(cfginfo,'OBJECT0.OUTPUT_FILE'))
          wb_filename_template = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.FILENAME_TEMPLATE')
          wb_detector          = (strsplit(file_basename(wb_filename_template),'_',/extr))[0]
          wb_image_data_dir    = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.IMAGE_DATA_DIR')
          wb_discard           = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.DISCARD')
          wb_dark_template     = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.DARK_TEMPLATE')
          wb_gain_file         = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.GAIN_FILE')
          wb_align_map         = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.ALIGN_MAP')
          wb_align_map_x       = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.ALIGN_MAP_X')
          wb_align_map_y       = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL0.ALIGN_MAP_Y')
          if has_diversity then begin
;            pdout = file_basename(redux_cfggetkeyword(cfginfo,'OBJECT0.OUTPUT_FILE'))
            pd_filename_template = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.FILENAME_TEMPLATE')
            pd_detector          = (strsplit(file_basename(pd_filename_template),'_',/extr))[0]
            pd_image_data_dir    = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.IMAGE_DATA_DIR')
            pd_discard           = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.DISCARD')
            pd_dark_template     = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.DARK_TEMPLATE')
            pd_gain_file         = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.GAIN_FILE')
            pd_align_map         = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.ALIGN_MAP')
            pd_align_map_x       = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.ALIGN_MAP_X')
            pd_align_map_y       = redux_cfggetkeyword(cfginfo,'OBJECT0.CHANNEL1.ALIGN_MAP_Y')
          endif
        endif else Ntrace = 1
        
        ;; Needed further down
        file_nums = red_expandrange(redux_cfggetkeyword(cfginfo,'IMAGE_NUMS')) 
        file_type = redux_cfggetkeyword(cfginfo,'FILE_TYPE', count = cnt) 
        if cnt eq 0 then file_type = 'ANA' ; Default in momfbd program.

        ;; Get prpara (processing parameters) from the global config keywords
        for ikey = 0, Nkeys-1 do begin
          if cfgkeys[ikey] eq '' || strmid(cfgkeys[ikey],0,6) eq 'OBJECT' then continue
          ;; Only global keywords lef at this point
          value = redux_cfggetkeyword(cfginfo,cfgkeys[ikey])
          case cfgkeys[ikey] of
            'SIM_X' : red_make_prpara, Gprpara, paraname = cfgkeys[ikey], red_expandrange(value)
            'SIM_Y' : red_make_prpara, Gprpara, paraname = cfgkeys[ikey], red_expandrange(value)
            'PROG_DATA_DIR' :   ; ignore
            else : begin
              if isa(value,/boolean) then begin
                if value then red_make_prpara, Gprpara, paraname = cfgkeys[ikey]
              endif else begin
                red_make_prpara, Gprpara, paraname = cfgkeys[ikey], value
              endelse
            end
          endcase
        endfor                  ; ikey

        ;; Parse objects
        tmp = where(strmatch(cfgkeys.toarray(),'OBJECT*'),Nobj)

        for iobj = 0, Nobj-1 do begin

          ;; Loop over objects, iobj = 0 is the WB anchor object
          ;; (possibly with phase diversity), iobj > 0 are NB objects.

          if keyword_set(no_narrowband) && iobj gt 0 then continue

          ;; If TRACE, then do every NB object cfg twice: once for the
          ;; NB object itself and once for the corresponding TRACE
          ;; object.
          for itrace = 0, Ntrace-1 do begin

            ;; Loop over NB object itrace=0, TRACE WB object itrace=1. 

            ;; Do the anchor object only once, no TRACE for that.
            if iobj eq 0 and itrace gt 0 then continue 
            
            print, 'iobj, itrace:', iobj, itrace

;            if itrace eq 0 then begin
            ;; The NB object
            objinfo = redux_cfggetkeyword(cfginfo,'OBJECT'+strtrim(iobj, 2))
;            endif else begin
;              ;; The TRACE object is object0
;              objinfo = redux_cfggetkeyword(cfginfo,'OBJECT0')
;            endelse
            
            objkeys = objinfo.keys()
            Nkeys   = objinfo.count()
            output_file = redux_cfggetkeyword(objinfo,'OUTPUT_FILE')
            thisdetector = (strsplit(file_basename(output_file),'_',/extr))[0]
            if itrace gt 0 then output_file = red_strreplace(output_file, thisdetector, wb_detector)
            header_file = cfg_dir + output_file + '.fitsheader'
            case file_type of
               'MOMFBD' : output_file += '.momfbd'
               'ANA'    : output_file += '.f0'
               'FITS'   : output_file += '.fits'
               else: stop
            endcase
         
            prpara = Gprpara[*] ; Start from the global parameters

            ;; Loop keywords
            for ikey = 0, Nkeys-1 do begin
              if objkeys[ikey] eq '' || strmid(objkeys[ikey],0,7) eq 'CHANNEL' then continue
              value = redux_cfggetkeyword(objinfo,objkeys[ikey])
              if isa(value,/boolean) then begin
                if value then red_make_prpara, prpara, paraname = objkeys[ikey]
              endif else begin
                red_make_prpara, prpara, paraname = objkeys[ikey], value
              endelse
            endfor              ; ikey
            
            tmp = where(strmatch(objkeys.toarray(),'CHANNEL*'), Nchan)
            ;; Look at the last channel, the first one might lack DIVERSITY and ALIGN_MAP. 
            chaninfo = redux_cfggetkeyword(objinfo,'CHANNEL'+strtrim(Nchan-1, 2))
            chankeys = chaninfo.keys()
            Nkeys    = chaninfo.count()

            if Nchan eq 1 then begin
              for ikey = 0, Nkeys-1 do begin
                if chankeys[ikey] eq '' then continue
                value = redux_cfggetkeyword(chaninfo,chankeys[ikey])
                if isa(value,/boolean) then begin
                  if value then red_make_prpara, prpara, paraname = chankeys[ikey]
                endif else begin
                  red_make_prpara, prpara, paraname = chankeys[ikey], value
                endelse
              endfor            ; ikey
            endif else begin
              ;; Prpara for channel keywords can have multiple values
              for ikey = 0, Nkeys-1 do begin
                if chankeys[ikey] eq '' then continue
                undefine, values
                for ichan = 0, Nchan-1 do begin
                  ;; Diversity channels
                  chaninfo = redux_cfggetkeyword(objinfo,'CHANNEL'+strtrim(ichan, 2))
                  value = redux_cfggetkeyword(chaninfo,chankeys[ikey])
                  if n_elements(value) eq 0 then begin
                    ;; Defaults for keywords possibly missing from the CHANNEL0.
                    case chankeys[ikey] of
                      'DIVERSITY' : value = '0.0'
                      'ALIGN_MAP' : value = '1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0'
                      else : stop
                    endcase
                  endif
                  ;; DIVERSITY could be just a number but could also
                  ;; have a unit attached and then be a string. So
                  ;; make sure we can handle a mix.
                  if chankeys[ikey] eq 'DIVERSITY' then value = strtrim(value, 2)
;                  print, ichan, ' ', value
                  red_append, values, value
                endfor          ; ichan
;                print, chankeys[ikey], ' ', values
                if isa(value,/boolean) then begin
                  if total(values) then red_make_prpara, prpara, paraname = chankeys[ikey], values
                endif else begin
                  red_make_prpara, prpara, paraname = chankeys[ikey], values
                endelse
              endfor            ; ikey
            endelse

            ;; Make lists of files actually involved in the sum.
            if iobj eq 0 then begin
              ;; Global WB, possibly with PD
              undefine, fnames
              for ifile = 0, n_elements(file_nums)-1 do begin
                ;; WB image
                fname = wb_image_data_dir + '/' $
                        + string(file_nums[ifile], format='(%"'+wb_filename_template+'")')
                if file_test(fname) then red_append, fnames, fname
                if has_diversity then begin
                  ;; PD image
                  fname = pd_image_data_dir + '/' $
                          + string(file_nums[ifile], format='(%"'+pd_filename_template+'")')
                  if file_test(fname) then red_append, fnames, fname
                endif
              endfor            ; ifile
            endif else begin
              ;; NB objects
              undefine, fnames
              chaninfo = redux_cfggetkeyword(objinfo,'CHANNEL'+strtrim(0, 2))
              filename_template = redux_cfggetkeyword(chaninfo,'FILENAME_TEMPLATE')
              image_data_dir    = redux_cfggetkeyword(chaninfo,'IMAGE_DATA_DIR')
              discard           = redux_cfggetkeyword(chaninfo,'DISCARD')
              for ifile = 0, n_elements(file_nums)-1 do begin
                fname = image_data_dir + '/' $
                        + string(file_nums[ifile], format='(%"'+filename_template+'")')
                if file_test(fname) then begin
                  if itrace eq 0 then begin
                    ;; NB - just add this file name
                    red_append, fnames, fname
                  endif else begin
                    ;; TRACE WB, possibly with PD - look for matching WB data
                    fname = wb_image_data_dir + '/' $
                            + string(file_nums[ifile], format='(%"'+wb_filename_template+'")')
                    if file_test(fname) then red_append, fnames, fname
                    if has_diversity then begin
                      ;; PD image
                      fname = pd_image_data_dir + '/' $
                              + string(file_nums[ifile], format='(%"'+pd_filename_template+'")')
                      if file_test(fname) then red_append, fnames, fname
                    endif
                  endelse
                endif
              endfor            ; ifile 
            endelse


;            if itrace eq 0 then begin
;              undefine, fnames, wb_fnames
;              for ichan = 0, Nchan-1 do begin 
;                chaninfo = redux_cfggetkeyword(objinfo,'CHANNEL'+strtrim(ichan, 2))
;                filename_template = redux_cfggetkeyword(chaninfo,'FILENAME_TEMPLATE')
;                image_data_dir    = redux_cfggetkeyword(chaninfo,'IMAGE_DATA_DIR')
;                discard           = redux_cfggetkeyword(chaninfo,'DISCARD')
;                for ifile = 0, n_elements(file_nums)-1 do begin
;                  fname = image_data_dir + '/' $
;                          + string(file_nums[ifile], format='(%"'+filename_template+'")')
;                  if file_test(fname) then begin
;                    red_append, fnames, fname
;                    ;; TRACE object filenames match the NB file names
;                    wb_fname = wb_image_data_dir + '/' $
;                               + string(file_nums[ifile], format='(%"'+wb_filename_template+'")')
;                    if file_test(wb_fname) then red_append, wb_fnames, wb_fname
;                    if has_diversity then begin
;                      ;; Add also the PD file names to wb_fnames
;                      pd_fname = pd_image_data_dir + '/' $
;                                 + string(file_nums[ifile], format='(%"'+pd_filename_template+'")')
;                      if file_test(pd_fname) then red_append, wb_fnames, pd_fname
;                    endif
;                  endif
;                endfor          ; ifile
;              endfor            ; ichan
;            endif

  
            ;; Make header corresponding to the sum.
            head = red_sumheaders(fnames, discard = discard)
            if has_diversity then prmode = 'Phase Diversity' else undefine, prmode 
            self -> headerinfo_addstep, head $
                                        , prstep = 'MOMFBD' $
                                        , prpara = prpara $
                                        , prmode = prmode $
                                        , addlib = 'momfbd/redux' 
            ;; At this point we don't know which program will be used,
            ;; momfbd or redux. Select one (if possible) and add version
            ;; number when reading the output.

            ;; Additional keywords that should be set after momfbd
            ;; processing.
            red_fitsaddkeyword, anchor = anchor, head, 'DATE-OBS', datestamp, after = 'DATE'
            red_fitsaddkeyword, anchor = anchor, head, 'STARTOBS', datestamp ; IS STARTOBS needed?
            red_fitsaddkeyword, anchor = anchor, head, 'SOLARNET', 1, format = 'f3.1'
            red_fitsaddkeyword, anchor = anchor, head, 'FILENAME', file_basename(output_file), 'MOMFBD restored data'

            if keyword_set(mosaic) then begin            

               red_fitsaddkeyword, anchor = anchor, head, 'MOS_TILE', mos_tile
              
             endif

            red_fitsaddkeyword, anchor = anchor, head, 'FILLED', 1, 'Missing pixels have been filled.'
            red_fitsaddkeyword, anchor = anchor, head, 'BTYPE', 'Intensity'
            red_fitsaddkeyword, anchor = anchor, head, 'BUNIT', 'DN' ; Digital unit?
            ;; DATE_OBS should be getting the value including decimals from
            ;; the raw data headers, not just integer seconds as here:

            ;; The CDELTn keywords should not change to HPLN-TAN/HPLT-TAN
            ;; until we know the position and orientation? /MGL
            red_fitsaddkeyword, anchor = anchor, head, 'CTYPE1', 'INSX-TAN', 'Instrument X'
            red_fitsaddkeyword, anchor = anchor, head, 'CTYPE2', 'INSY-TAN', 'Instrument Y'
            red_fitsaddkeyword, anchor = anchor, head $
                                , 'CDELT1', float(self.image_scale), 'x-coordinate increment'
            red_fitsaddkeyword, anchor = anchor, head $
                                , 'CDELT2', float(self.image_scale), 'y-coordinate increment' 
            red_fitsaddkeyword, anchor = anchor, head, 'CUNIT1', 'arcsec', 'Unit along axis 1'
            red_fitsaddkeyword, anchor = anchor, head, 'CUNIT2', 'arcsec', 'Unit along axis 2'

            self -> extractstates, fnames, states
            if states[0].is_wb then begin
              state = states[0].prefilter + '_' + states[0].tuning
              red_fitsaddkeyword,  anchor = anchor, head, 'STATE', state, 'Added by prepmomfbd_fitsheaders'
            endif
            
            ;; Write the header file
            fxaddpar,head,'EXTEND','T' ; Required by fxwrite
            fxwrite, header_file, head 
            
          endfor                ; itrace
          
        endfor                  ; iobj
        
      endfor                    ; icfg
      
    endfor                      ; ipref

  endfor                        ; idir

end



cd, '/scratch/mats/2024-04-21/CHROMIS'
a = chromisred("config.txt",/no, /dev)
root_dir = "/data/2024/2024.04/2024.04.21/"   
;a -> prepmomfbd_fitsheaders, pref='3950', dirs=root_dir + 'CHROMIS-data/08:06:20'
a -> prepmomfbd_fitsheaders, pref='3950', dirs=root_dir + 'CHROMIS-mosaic/09:11:11', /mosaic


end

