; docformat = 'rst'

;+
; Write FITS header files for expected MOMFBD output.
; 
; :Categories:
;
;    SST pipeline
; 
; 
; :Author:
; 
;    Mats LÃ¶fdahl, ISP
; 
; 
; 
; :Keywords:
;
;    no_pd : in, optional, type=boolean
;   
;       Set this to exclude phase diversity data and processing. 
;   
;    momfbddir : in, optional, type=string, default='momfbd'
;   
;       Top directory of output tree.
;   
; 
;    dirs : in, optional, type=strarr
;   
;       The data "timestamp" directories to process.
;   
;    pref : in, optional, type=string
;
;       Prefilter. 
; 
; :History:
; 
;    2017-03-16 : MGL. First version.
; 
;    2017-03-24 : MGL. Add header information about this processing step.
; 
;    2017-06-01 : MGL. Use red_fitsaddpar. Change some added parameters.
;
;    2017-09-07 : MGL. Changed red_fitsaddpar --> red_fitsaddkeyword. 
; 
;    2018-03-29 : MGL. Make fitsheader files for extra WB objects
;                 generated by use of TRACE keyword in redux config
;                 file.
;
; 
;-
pro red::prepmomfbd_fitsheaders, dirs = dirs $
                                 , momfbddir = momfbddir $
                                 , pref = pref $
                                 , scanno = scanno $
                                 , no_pd = no_pd 
  
  ;; Name of this method
  inam = red_subprogram(/low, calling = inam1)  

  if n_elements(dirs) gt 0 then begin
    dirs = [dirs] 
  endif else begin
    if ~ptr_valid(self.data_dirs) then begin
      print, inam+' : ERROR : undefined data_dir'
      return
    endif
    dirs = *self.data_dirs
  endelse

  Ndirs = n_elements(dirs)
  if Ndirs eq 0 then return
 
  if n_elements(momfbddir) eq 0 then begin
    if keyword_set(no_pd) then begin
      momfbddir = 'momfbd_nopd' 
    endif else begin
      momfbddir = 'momfbd' 
    endelse
  endif

  ;; Loop directories
  for idir=0L, Ndirs-1 do begin
    
    dir = dirs[idir]+'/'
    folder_tag = file_basename(dir)
    datestamp = self.isodate+'T'+folder_tag
    
    ;; base output location
    cfg_base_dir = self.out_dir + PATH_SEP() + momfbddir + PATH_SEP() + folder_tag + PATH_SEP()

    if n_elements(pref) gt 0 then begin
      prefs = pref
      Nprefs = n_elements(prefs)
    endif else begin
      prefs = file_basename(file_search(cfg_base_dir+'*', count = Nprefs))
    endelse
    
    for ipref = 0, Nprefs-1 do begin
      
      cfg_dir = cfg_base_dir + PATH_SEP() + prefs[ipref] + PATH_SEP() + 'cfg/'
      cfg_files = file_search(cfg_dir + 'momfbd_reduc_' + prefs[ipref] $
                              + '_?????.cfg', count = Ncfg)
      
      progress_msg = 'Making fits headers for ' $
                     + red_strreplace(red_strreplace(cfg_dir,'//','/') $
                                      , self.out_dir,'')

      ;; Parse all config files, make fitsheaders for all output files
      for icfg = 0, Ncfg-1 do begin

        red_progressbar, icfg, Ncfg, progress_msg, /predict

    
        if n_elements(scanno) ne 0 then $
           if long(scanno) ne long((strsplit(file_basename(cfg_files[icfg],'.cfg') $
                                             ,'_',/extract))[3]) then $
                                                continue
        

        spawn, 'cat '+cfg_files[icfg], cfg
        Nlines = n_elements(cfg)

        ;; Find out whether this is a cfg file with TRACE so we have
        ;; to generate fitsheader files for the implicit extra WB
        ;; output files.
        dum = where(cfg eq 'TRACE',cnt)
        do_trace = cnt gt 0
        if do_trace then begin
          Ntrace = 2
          wbout = file_basename(cfg[(where(strmatch(cfg,'*OUTPUT_FILE*')))[0]])
          wbcam = (strsplit(file_basename(wbout),'_',/extr))[0]
        endif else Ntrace = 1
        
        ;; Get prpara (processing parameters) from the global config keywords
        Gstart = (where(strmatch(cfg,'}*'),Nmatch))[Nmatch-1] + 1
        undefine, Gprpara       ; Start fresh
        for iline = Gstart, Nlines-1 do begin
          if cfg[iline] ne '' then begin
            cfgsplit = strsplit(cfg[iline], '=', /extract)
            
            case cfgsplit[0] of
              ;; Make list of possible global keywords complete!
              'FILE_TYPE' : begin
                file_type = cfgsplit[1]
                red_make_prpara, Gprpara, paraname = cfgsplit[0], cfgsplit[1]
              end
              'IMAGE_NUMS'      : begin
                ;; These are actually file numbers, several frames in each file.
                file_nums = red_expandrange(cfgsplit[1]) ; Needed further down
                red_make_prpara, Gprpara, paraname = cfgsplit[0], cfgsplit[1]
              end
              ;;'MODES' : red_make_prpara, Gprpara, paraname = cfgsplit[0], red_expandrange(cfgsplit[1])
              'MODES' : red_make_prpara, Gprpara, paraname = cfgsplit[0], cfgsplit[1]
              'SIM_X' : red_make_prpara, Gprpara, paraname = cfgsplit[0], red_expandrange(cfgsplit[1])
              'SIM_Y' : red_make_prpara, Gprpara, paraname = cfgsplit[0], red_expandrange(cfgsplit[1])
              ;; Ignored config lines:
              'PROG_DATA_DIR' : 
              else : begin
                case n_elements(cfgsplit) of
                  1: red_make_prpara, Gprpara, paraname = cfg[iline], ''
                  2: red_make_prpara, Gprpara, paraname = cfgsplit[0], cfgsplit[1]
                  else: stop
                endcase
              end
            endcase
          endif

        endfor                  ; iline

        ;; Parse objects
        Ostarts = where(strmatch(cfg,'object{*'),Nobj)
        for iobj = 0, Nobj-1 do begin

          for itrace = 0, Ntrace-1 do begin
          
            prpara = Gprpara[*] ; Start from the global parameters

            Ostart = Ostarts[iobj]
            Oend   = Ostart + (where(strmatch(cfg[Ostart:*],'}*'),Nmatch))[0]
            Cstarts = Ostart + where(strmatch(cfg[Ostart:Oend],'*channel{*'),Nchan)

            ;; Parse object keywords
            for iline = Ostart, Cstarts[0]-1 do begin
              cfgline = strtrim(cfg[iline], 2)
              if ~strmatch(cfgline,'*{') and ~strmatch(cfgline,'*}') then begin
                cfgsplit = strsplit(cfgline, '=', /extract)
                case cfgsplit[0] of
                  'OUTPUT_FILE' : begin
                    output_file = cfgsplit[1]
                    thiscam = (strsplit(file_basename(output_file),'_',/extr))[0]
                    if itrace gt 0 && thiscam ne wbcam then begin
                      output_file = red_strreplace(output_file, thiscam, wbcam)
                    endif
                    red_make_prpara, prpara, paraname = 'OUTPUT_FILE', output_file
                  end
                  else : begin
                    case n_elements(cfgsplit) of
                      1: red_make_prpara, prpara, paraname = cfg[iline], ''
                      2: red_make_prpara, prpara, paraname = cfgsplit[0], cfgsplit[1]
                      else: stop
                    endcase
                  end
                endcase
              endif
            endfor              ; iline

            if n_elements(file_type) eq 0 then file_type = 'ANA' ; Default in momfbd program.
            header_file = cfg_dir + output_file + '.fitsheader'
            case file_type of
              'MOMFBD' : output_file += '.momfbd'
              'ANA'    : output_file += '.f0'
              'FITS'   : output_file += '.fits'
              else: stop
            endcase

            
            ;; Channels
            if Nchan gt 1 and ~keyword_set(no_pd) then prmode = 'Phase Diversity' else undefine, prmode 

;;            for ichan = Nchan-1, 0, -1 do begin
            begin
              ichan = 0
                
              Cstart = Cstarts[ichan]
              Cend   = Cstart + (where(strmatch(cfg[Cstart:*],'*}*'),Nmatch))[0]


              if itrace eq 0 then begin

                ;; Don't make PRPARA with these keywords for TRACE
                ;; objects. The corresponding settings are not
                ;; parameters, they are auto-generated by the redux
                ;; program.
                
                undefine, discard
                for iline = Cstart, Cend do begin
                  cfgline = strtrim(cfg[iline], 2)
                  if ~strmatch(cfgline,'*{') and ~strmatch(cfgline,'*}') then begin
                    cfgsplit = strsplit(cfgline, '=', /extract)
                    case cfgsplit[0] of
                      'ALIGN_CLIP' : red_make_prpara, prpara, paraname = cfgsplit[0] $
                                                      , red_expandrange(cfgsplit[1])
                      'FILENAME_TEMPLATE' : begin
                        filename_template = cfgsplit[1]
                        red_make_prpara, prpara, paraname = cfgsplit[0], cfgsplit[1]
                      end
                      'GAIN_FILE'         : begin
                        gain_file = cfgsplit[1]
                        red_make_prpara, prpara, paraname = cfgsplit[0], cfgsplit[1] 
                      end
                      'IMAGE_DATA_DIR'    : begin
                        image_data_dir = cfgsplit[1]
                        red_make_prpara, prpara, paraname = cfgsplit[0], cfgsplit[1]
                      end
                      'DISCARD'           : begin
                        discard = long(cfgsplit[1])
                        red_make_prpara, prpara, paraname = cfgsplit[0], cfgsplit[1]
                      end
                      else : begin
                        case n_elements(cfgsplit) of
                          1: red_make_prpara, prpara, paraname = cfg[iline], ''
                          2: red_make_prpara, prpara, paraname = cfgsplit[0], cfgsplit[1]
                          else: stop
                        endcase
                      end
                    endcase
                  endif
                endfor          ; iline

                if thiscam eq wbcam then begin
                  wb_filename_template = filename_template
                  wb_image_data_dir = image_data_dir
                endif else begin
                  nb_filename_template = filename_template
                  nb_image_data_dir = image_data_dir
                endelse
                
              endif else begin
                ;; Change some info for the TRACE objects
                filename_template = wb_filename_template 
                image_data_dir = wb_image_data_dir
              endelse
                                
              if ichan eq 0 then begin
                ;; Make a list of files actually involved in the sum.
                undefine, fnames
                for ifile = 0, n_elements(file_nums)-1 do begin
                  if iobj eq 0 then begin
                    ;; First object is the anchor object, which is WB
                    ;; but not a trace object. 
                    fname = image_data_dir + '/' $
                            + string(file_nums[ifile], format='(%"'+filename_template+'")')
                    if file_test(fname) then red_append, fnames, fname
                  endif else begin
                    nb_fname = nb_image_data_dir + '/' $
                               + string(file_nums[ifile], format='(%"'+nb_filename_template+'")')
                    ;; Let non-trace (NB) files decide whether to include numbers
                    efiles = file_test(nb_fname) 
                    if efiles then begin
                      if itrace eq 0 then begin
                        red_append, fnames, nb_fname
                      endif else begin
                        wb_fname = wb_image_data_dir + '/' $
                                   + string(file_nums[ifile], format='(%"'+wb_filename_template+'")')
                        red_append, fnames, wb_fname
                      endelse
                    endif
                  endelse
                endfor          ; ifile
                Nfiles = n_elements(fnames)
                if Nfiles eq 0 then stop
                
              endif

            endfor              ; ichan

            if n_elements(fnames) eq 0 then begin
              print, inam+' : WARNING, no files for '+filename_template
              continue
            endif

            ;; Make header corresponding to the sum.
            head = red_sumheaders(fnames, discard = discard)
            self -> headerinfo_addstep, head $
                                        , prstep = 'MOMFBD' $
                                        , prpara = prpara $
                                        , prmode = prmode $
                                        , addlib = 'momfbd/redux' 
            ;; At this point we don't know which program will be used,
            ;; momfbd or redux. Select one (if possible) and add version
            ;; number when reading the output.

            ;; Additional keywords that should be set after momfbd
            ;; processing.
            red_fitsaddkeyword, anchor = anchor, head, 'DATE-OBS', datestamp, after = 'DATE'
            red_fitsaddkeyword, anchor = anchor, head, 'STARTOBS', datestamp ; IS STARTOBS needed?
            red_fitsaddkeyword, anchor = anchor, head, 'SOLARNET', 1, format = 'f3.1'
            red_fitsaddkeyword, anchor = anchor, head, 'FILENAME', file_basename(output_file), 'MOMFBD restored data'
            red_fitsaddkeyword, anchor = anchor, head, 'FILLED', 1, 'Missing pixels have been filled.'          
            red_fitsaddkeyword, anchor = anchor, head, 'BTYPE', 'Intensity'
            red_fitsaddkeyword, anchor = anchor, head, 'BUNIT', 'DN' ; Digital unit?
            ;; DATE_OBS should be getting the value including decimals from
            ;; the raw data headers, not just integer seconds as here:

            ;; The CDELTn keywords should not change to HPLN-TAN/HPLT-TAN
            ;; until we know the position and orientation? /MGL
            red_fitsaddkeyword, anchor = anchor, head, 'CTYPE1', 'INSX-TAN', 'Instrument X'
            red_fitsaddkeyword, anchor = anchor, head, 'CTYPE2', 'INSY-TAN', 'Instrument Y'
            red_fitsaddkeyword, anchor = anchor, head $
                                , 'CDELT1', float(self.image_scale), 'x-coordinate increment'
            red_fitsaddkeyword, anchor = anchor, head $
                                , 'CDELT2', float(self.image_scale), 'y-coordinate increment' 
            red_fitsaddkeyword, anchor = anchor, head, 'CUNIT1', 'arcsec', 'Unit along axix 1'
            red_fitsaddkeyword, anchor = anchor, head, 'CUNIT2', 'arcsec', 'Unit along axix 2'

            ;; Write the header file
            fxaddpar,head,'EXTEND','T' ; Required by fxwrite
            fxwrite, header_file, head 

          endfor                ; itrace
          
        endfor                  ; iobj
        
      endfor                    ; icfg

    endfor                      ; ipref

  endfor                        ; idir

end

